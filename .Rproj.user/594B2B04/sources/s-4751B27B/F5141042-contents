MIMIR <- methods::setClass("MIMIR", 
                           slots = c(name="character",
                                     exp.data = "matrix",
                                     smoothed.exp = "matrix",
                                     genes = "vector",
                                     pseudotime = "vector",
                                     exp.dis = "array",
                                     exp.sim = "array",
                                     func.sim = "array",
                                     integrated.sim = "array",
                                     clusters = "list",
                                     annotations = "list",
                                     gene.info = "data.frame"
                                     ))

setMethod(f = "show", signature = "MIMIR",
          definition = function(object) {
            if(is.null(object@pseudotime)){
              pt=" with no temporal information: "
            }else{
              pt=" with temporal information: "
            }
            cat("MIMIR object for ", name, pt,
                nrow(object@exp.data), " genes x",
                ncol(object@exp.data), "cells.\n")
            invisible(NULL)
            }
          )

createMIMIR <- function(name, exp.data, genes = NULL, pseudotime = NULL) {
  if(is.null(genes)){
    genes=rownames(exp.data)
  }else{
    genes=intersect(genes,rownames(exp.data))
  }
  if(is.null(pseudotime)){
    ## test if the expression data column name contain numeric values that can be used as pseudotime
    if(sum(is.na(as.numeric(colnames(exp.data))))==0){
      pseudotime=as.numeric(colnames(exp.data))
    }
  }else{
    if(sum(is.na(as.numeric(pseudotime)))>0){
      message("pseeudotime argument unused. Input contains non-numeric values.")
      pseudotime=NULL
    }else{
      if(length(pseudotime)!=dim(exp.data)[2]){
        message("pseeudotime argument unused. Input doesn't match number of columns in exp.data.")
        pseudotime=NULL
      }else{
        pseudotime=as.numeric(pseudotime)
      }
    }
  }
  object <- methods::new("MIMIR", name=name, exp.data=exp.data, genes=genes)
  if(!is.null(pseudotime)){
    object@pseudotime <- pseudotime
    sums=apply(exp.data,1,sum)
    ave.time=apply(pseudotime*t(exp.data),2,sum)/sums
    object@gene.info <- data.frame("weighted.time"=ave.time, row.names = rownames(exp.data))
  }
  return(object)
} 


Anno <- methods::setClass("Anno", 
                           slots = c(db="character",
                                     gene.anno="data.frame",
                                     genes = "vector",
                                     bg.genes="vector",
                                     IC = "vector",
                                     cat.IC = "list",
                                     hierarchy.df = "data.frame",
                                     hierarchy.l = "list",
                                     descrip = "data.frame",
                                     similarity="matrix",
                                     adj.similarity="matrix"
                           ))

setMethod(f = "show", signature = "Anno",
          definition = function(object) {
            cat("Anno object. Database used: ", object@db, ".\n")
            invisible(NULL)
          }
)

createAnno <- function(db, gene.anno, gene.col=1, id.col=2, cat.col=NULL, genes = NULL, bg.genes = NULL, 
                       hierarchy.df=NULL, parent.col=1, child.col=2, hierarchy.l=NULL){
  gene.anno.use=data.frame('gene'=gene.anno[,gene.col], 'id'=gene.anno[,id.col])
  if(!is.null(cat.col)){
    gene.anno.use$category=gene.anno[,cat.col]
  }
  if(!is.null(genes)){
    if(length(setdiff(genes, gene.anno.use$gene))>0){
      n=length(setdiff(genes, gene.anno.use$gene))
      message(paste0(n,' genes are not found in the gene.anno table'))
      genes=intersect(genes, gene.anno.use$gene)
    }
  }
  if(!is.null(bg.genes)){
    if(length(setdiff(bg.genes, gene.anno.use$gene))>0){
      n=length(setdiff(bg.genes, gene.anno.use$gene))
      message(paste0(n,' background genes are not found in the gene.anno table'))
      bg.genes=intersect(bg.genes, gene.anno.use$gene)
    }
  }
  if(!is.null(genes) && is.null(bg.genes)){
    all.genes=union(genes,bg.genes)
    if(length(setdiff(gene.anno.use$genes, all.genes))>0){
      message("Subsetting gene.anno table to remove genes not in the input gene or bg.genes...")
      gene.anno.use=gene.anno.use[which(gene.anno.use$gene%in%all.genes),]
    }
  }
  object <- methods::new("Anno", db=db, gene.anno=gene.anno.use)
  if(!is.null(genes)){
    object@genes = genes
  }
  if(!is.null(bg.genes)){
    object@bg.genes = bg.genes
  }
  if(!is.null(hierarchy.df)){
    object@hierarchy.df <- data.frame('parent'=hierarchy.df[,parent.col], 'child'=hierarchy.df[, child.col])
    object@hierarchy.l <- offspring.list(object@hierarchy.df)
  }
  if(!is.null(hierarchy.l)){
    if(is.null(hierarchy.df)){
      object@hierarchy.l = hierarchy.l
      p2c=stack(hierarchy.l)
      p2c=p2c[,c(2,1)]
      colnames(p2c)=c("parent","child")
      p2c=as.data.frame(as.matrix(p2c))
      object@hierarchy.df = p2c
    }else{
      message("Argument hierarchy.l unused. hierarchy.l calculated from the supplied hiearchy.df.")
    }
  }
  return(object)
} 