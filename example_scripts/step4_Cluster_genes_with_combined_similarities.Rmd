---
title: 'Step4: Cluster with combined similarities'
author: "Yiqun Wang"
output: github_document
---
In this example, we will cluster the notochord-enriched genes (identified in Step1) based on their expression similarities (calculated in Step2) as well as their functional similarities (calculated in Step3). 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r}
source("../functions/combine_scores_and_cluster.R")
```

## Load previously calculated expression and functional similarities
```{r}
## Expression similarity scores:
exp_sim = readRDS("../example_results/exp_similarities.rds")
exp_sim=exp_sim$noto
print(dimnames(exp_sim)[[3]]) ## distances were already converted to similarities dispite the names
## Functional similarity scores:
anno_sim = readRDS("../example_results/notochord_functional_similarities.RDS")
print(dimnames(anno_sim)[[3]])
```

## Integrate expression and functional similarities
We can calculate the integrated score for each expression and functional similarity pair, e.g. cos_dist and STRING, or jsdiv and string_ExpTxt+GO+Reactome+Interpro. We will try different expression-function combinations and different integration methods and compare the clustering results derived from them. 

```{r}
## will calculate combinations of the following similarities
exp_use = c("soft_cos", "euc", "canb", "jsdis")
anno_use = c("string_noDB+GO+Reactome+Interpro", "string_noDB+GO_noCC+Reactome+Interpro", "string_ExpTxt+GO+Reactome+Interpro",
             "GO+Reactome+Interpro", "GO", "STRING", "Reactome")
```

### 1. Expression OR function: S = 1-(1-Se)(1-Sa) 
Integrated score will be high if either expression or functional similarity is high. For instance, a high expression similarity combined with a low functional similarity will still give a high score. 
```{r}
simOR=integrate_all_exp_anno(exp_sim, anno_sim, exp_use=exp_use, anno_use=anno_use, method="OR",minmax=c(0.05,1))
## simOR is a 3d array
dim(simOR)
dimnames(simOR)[[3]]
saveRDS(simOR,"../example_results/notochord_OR_integrated_sim.rds", compress = "xz")
```

### 2. Expression AND function: S = Se*Sa
Integrated score will be high if both expression and functional similarities are high.
```{r}
simAND=integrate_all_exp_anno(exp_sim, anno_sim, exp_use=exp_use, anno_use=anno_use, method="AND",minmax=c(0.05,1))
## simOR is a 3d array
dimnames(simAND)[[3]]
saveRDS(simAND,"../example_results/notochord_AND_integrated_sim.rds", compress = "xz")
```

### 3. Expression + function: S = Se + Sa
```{r}
simPlus=integrate_all_exp_anno(exp_sim, anno_sim, exp_use=exp_use, anno_use=anno_use, method="+",minmax=c(0.05,1))
## simOR is a 3d array
dimnames(simPlus)[[3]]
```
## Cluster the genes using integrated similarities scores
In our `igraph_clus` function, we use functions from the [igraph](https://r.igraph.org/) package to turn similarity matrices into gene networks and cluster the genes accordingly, using either built-in methods in igraph, or leiden algorithm from the [leiden](https://cran.r-project.org/web/packages/leiden/index.html) package. 
```{r, eval=F}
## Initiate a list object to store cluster results from different similarity scores
clus_noto=list()

## Try 3 different clustering methods: louvain, infomap, and leiden. Leiden needs additional resolution and partition method parameters
## try a few resolution parameters for leiden
res=c(2,2.5,3,3.5,4,5)

## Cluster
## Each for loop will loop through scores and clustering methods, which can take a long time. Clustering with different scores and clustering methods can be parallelized to speed up the calculation.
### 1. with OR integrated scores. 
for(s in dimnames(simOR)[[3]]){
  print(s)
  clus_noto[[s]]=igraph_cls(simOR[,,s], method=c("louvain","infomap","leiden"),leiden_res=res,
                                leiden_iter = 50, leiden_par=c("RBConfigurationVertexPartition"), seed=1)
}

### 2. with AND integrated scores. 
for(s in dimnames(simAND)[[3]]){
  print(s)
  clus_noto[[s]]=igraph_cls(simAND[,,s], method=c("louvain","infomap","leiden"),leiden_res=res,
                                leiden_iter = 50, leiden_par=c("RBConfigurationVertexPartition"), seed=1)
}

### 3. with + integrated scores
for(s in dimnames(simPlus)[[3]]){
  print(s)
  clus_noto[[s]]=igraph_cls(simPlus[,,s], method=c("louvain","infomap","leiden"),leiden_res=res,
                                leiden_iter = 50, leiden_par=c("RBConfigurationVertexPartition"), seed=1)
}
```
### Cluster with only expression or only functional similarities too for comparison
```{r, eval=F}
for(s in dimnames(exp_sim)[[3]]){
  print(s)
  clus_noto[[s]]=igraph_cls(exp_sim[,,s], method=c("louvain","infomap","leiden"),leiden_res=res,
                                leiden_iter = 50, leiden_par=c("RBConfigurationVertexPartition"), seed=1)
}

for(s in dimnames(anno_sim)[[3]]){
  print(s)
  clus_noto[[s]]=igraph_cls(anno_sim[,,s], method=c("louvain","infomap","leiden"),leiden_res=res,
                                leiden_iter = 50, leiden_par=c("RBConfigurationVertexPartition"), seed=1)
}
```

### Save all clustering results
```{r, eval=F}
saveRDS(clus_noto, "../example_results/notochord_all_clusters.rds")
```

### Check how cluster results look
```{r}
clus_noto=readRDS("../example_results/notochord_all_clusters.rds")
head(clus_noto$`GO:OR:soft_cos`) ## each matrix contains cluster ids
```

